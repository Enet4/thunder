//!

#![feature(proc_macro, proc_macro_lib)]
#![allow(unused_imports, unused_variables)]

extern crate proc_macro;

#[macro_use]
extern crate syn;

#[macro_use]
extern crate quote;

use proc_macro::TokenStream;
use quote::ToTokens;
use std::collections::HashSet as Set;
use syn::LitStr;
use syn::fold::{self, Fold};
use syn::punctuated::Punctuated;
use syn::synom::Synom;
use syn::{Expr, FnArg, Ident, ImplItem, ImplItemMethod, Item, ItemImpl, ItemStatic, Pat, Stmt,
          Type};

///
#[proc_macro_attribute]
pub fn thunderclap(_args: TokenStream, input: TokenStream) -> TokenStream {
    let i: ItemImpl = match syn::parse(input.clone()) {
        Ok(input) => input,
        Err(e) => panic!("Error: '{}'", e),
    };

    let name = match *i.self_ty {
        Type::Path(ref p) => format!("{}", p.path.segments[0].ident),
        _ => format!("Unknown App"),
    };

    let about = match i.attrs.first() {
        Some(a) => String::from(
            format!("{}", a.tts)
                        /* Clean the tokens TODO: Make this not suck */
                        .replace("/", "")
                        .replace("\\", "")
                        .replace("\"", "")
                        .replace("=", "").trim(),
        ),
        _ => String::new(),
    };

    let orignal = quote!(#i);

    let mut app = quote! {
        App::new(#name).about(#about)
    };

    let mut functions: Vec<(String, usize)> = Vec::new();

    for item in &i.items {
        match item {
            &ImplItem::Method(ref i) => {
                let name = LitStr::new(&i.sig.ident.to_string(), i.sig.ident.span);
                let about = match i.attrs.first() {
                    Some(a) => String::from(
                        format!("{}", a.tts)
                        /* Clean the tokens TODO: Make this not suck */
                        .replace("/", "")
                        .replace("\\", "")
                        .replace("\"", "")
                        .replace("=", "").trim(),
                    ),
                    _ => String::new(),
                };

                let mut func = (format!("{}", name.value()), 0);

                let args = i.sig
                    .decl
                    .inputs
                    .iter()
                    .fold(quote!{}, |acc, arg| match arg {
                        &FnArg::Captured(ref arg) => match &arg.pat {
                            &Pat::Ident(ref i) => {
                                func.1 += 1;
                                let n = format!("{}", i.ident);
                                quote! { #acc.arg(Arg::with_name(#n)).about(#about) }
                            }
                            _ => quote!{ #acc },
                        },
                        _ => quote!{ #acc },
                    });

                app = quote! {
                    #app.subcommand(
                        SubCommand::with_name(#name)#args
                    )
                };

                functions.push(func);
            }
            _ => {},
        }
    }

    let mut matchy = quote!{ match args.subcommand() "{" };

    for func in &functions {
        
    }

    // match matches.subcommand() {
    //     ("hello", Some(matches)) => println!("{:#?}", matches.args),
    //     _ => panic!("This is a real problem!"),
    // }

    println!("{:#?}", functions);

    /* Build ... match links (I think) */
    // for function in &functions {
        // let name = format!("{}", function);



        // let fo = quote! { (#name, Some(m)) =>  };

//         ("migrations", Some(matches)) => run_migration_command(matches),
//         ("setup", Some(matches)) => setup::handle_setup(matches),
// _ => unreachable!("Can't touch this..."),
    // }

    let tokens = quote! {
            #orignal

            /// This block was generated by thunder v0.0.0
            impl Thor {

                /// Starts the CLI parsing and calls whichever function handles the input
                fn start() {
                    // let generated = quote! {
                    //     #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
                    //     const #dummy_const: () = {
                    //         extern crate serde as _serde;
                    //         #impl_block
                    //     };
                    // };

                    use clap::{App, SubCommand, Arg};

                    let mut app = #app;
                    let args = app.get_matches();
                    println!("Matched:\n{:#?}", args);
                }
            }
        };

    tokens.into()
}
